# Wearable Concept 2 SDK, Android Quick Start
**PLT Labs**  
API version: .8  
Document version .8  
August 5, 2015  
[morgan.davis@plantronics.com](mailto:morgan.davis@plantronics.com)  

## Introduction
This document serves as a quick-start to using the Wearable Concept 2 Android SDK for building mobile applications. The Android version of the SDK is a Java implementation of the generic API described in the “WC2 Generalized API” document.## PrerequisitesTo use the WC2 SDK, your system must meet the following requirements:
### Development Environment+	Mac or PC with the Android Studio installed. Other IDEs can be used but are not described in this document.### Mobile Device+	Android phone or tablet with Bluetooth capability and Android version 4.4 or later (API level 19 or later).## Conventions
The Android API uses several patterns to achieve the functionality outlined in the generalized API.

###	Static methodsThe *com.plantronics.Device* class employs two static method, *initialize()* and *getPairedDevices()*. These methods are used to initialize the SDK before use, and to retrieve a master list of paired devices after initialization.
	###	Callback interfaces+	The *ConnectionListener* interface is used to notify client objects when an instance of *Device* opens a connection, failures to open a connection, or closes a connection. It is defined as follows: ```public interface ConnectionListener {	public void onConnectionOpen(Device device);	public void onConnectionFailed(Device device, int error);	public void onConnectionClosed(Device device);}
```+	The *SnapshotListener* interface is used to deliver service info when queried with *Device.queryUpdate()* or when new info is available for an observer subscribed with *Device.subscribe()*:```public interface SnapshotListener {	public void onSnapshotReceived:(Snapshot snapshot);	public void onSubscriptionChanged:(ServiceSubscription oldSubscription, 						  ServiceSubscription newSubscription);}
```+	The *PairingListener* interface is used to notify client objects when a new Wearable Concept device is paired with or unpaired from the host Android device: ```public interface PairingListener {	public void onDevicePaired(Device device);	public void onDeviceUnpaired(Device device);}
```
## Quick Start
This section will guide you through obtaining the SDK, connecting your Concept a to your Android device, setting up your Android Studio project, and discovering, connecting to, and retrieving data from the device.

### Obtaining the SDKThe *wc2-sdk-example* example project can be found accompanying this document or in the Git repository located at [https://github.com/plantronics-innovation/android-wc2-sdk-example](). The actual WC2 SDK file (*wc2sdk.aar*) is located inside the *wc2sdk* subdirectory of the project's directory.
###	Pairing Concept 2 with your mobile deviceBefore using Concept 2 you will need to pair it over Bluetooth to your Android device. To pair Concept 2, power it on using the power switch on the back panel of the device, then hold the *answer/end call button* located at the back end of the boom until the status indicator light begins to blink red/blue.Once in pairing mode, open the **Settings** app on your Android device and navigate to the **Bluetooth** settings. From the **Menu** choose the **Search for devices** option. When visible, tap the device labeled “PLT_WC2”. The “PLT_WC1” device should now be paired with your Android device and display “Connected” next to its name.

###	Installing PLTHub on your Android deviceAll apps using the WC2 SDK library talk through a central point, the *PLTHub* app. The PLTHub apk can be found accompanying this document or in the Git repository located at [https://github.com/plantronics-innovation/android-wc2-sdk-example]().  and must be manually installed on your Android device prior to using the API.1.	Enable USB Debugging on the device [http://developer.android.com/tools/device.html]() and connect it to your development machine via USB. 2.	Open a shell (Windows or OS X) and set your working directory to the same directory as the *adb* executable in your Android SDK install directory ([http://developer.android.com/tools/help/adb.html]()).5.	Use *adb* to install PLTHub.apk on the connected Android device with following command:```./adb install <<path-to-PLTHub.apk>>
```5)	You must start the *PLTHub* service on the Android device by manually navigating to and launching the “PLT Hub” application. PLT Hub will display “Headset Unsupported” -- you may dismiss the message and exit the app.###	Setting up your Android Studio project+	Select **File** -> **New...** -> **New Project...** and follow the steps to create a new Android application using API level 19 or later and whichever interface template you desire.+	Add the following elements to the app's *AndroidManifest.xml* file: ```<uses-sdk android:minSdkVersion="15" android:targetVersion="19" /> <uses-permission android:name="android.permission.BLUETOOTH" /><uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /> 
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
```+	Add the *wc2sdk.aar* lirbary to your project by selecting **File** -> **New...** -> **New Module...** Select **Import JAR/AAR Package** and navigate to and choose the wc2sdk.aar file. Your app will now link against the WC2 SDK when building.

###	Initializing the SDKFor every instance of an application linking to the SDK, the SDK must be initialized before it can be used. Initialization is done using the *Device.initialize()* static method. The method takes two arguments, a *Context* and an instance of the *InitializationCallback* class. *InitializationCallback* defines two methods:

```public static abstract class InitializationCallback {	public abstract void onInitialized();	public abstract void onFailure(int error);}
```
Initialization could be done, for example, in *onCreated()* of your application’s main activity. Once initialization is complete you may begin using other features of the SDK. If *onFailure()* is called, the reason for the failure can be found by comparing the code error to the "*ERROR_*" prefixed constants defined at the top of *Device.java*.###	Iterating over and connecting to available devices*Device* contains the static method *getPairedDevices()* that is used after initialization to retrieve a list of paired Concept 2 devices. Additionally, your app can provide to the *Device.addPairingListener()* method an object that adheres to the *PairingListener* interface to receive callbacks when a new device is paired or unpaired. Similar to *PairingListener*, objects adhering to the *ConnectionListener* interface can be added using *Device.addConnectionListener()* to receive connection-related callbacks. The following code could be embedded in a class implementing *PairingListener* and *ConnectionListener* to search for and connect to paired devices after initialization (via a call to *tryConnect()* after initialization), and connect to new devices as they are paired:

```private Device _device;// called from InitializationCallback’s onInitialized()public void tryConnect() {	ArrayList<Device> devices = Device.getPairedDevices();	if (devices.size() > 0) {		_device = devices.get(0);		_device.registerConnectionListener(this);		_device.openConnection();	}	else {		// no paired devices found	} }public void onConnectionOpen(Device device) {	// may begin subscribing to services, querying services, etc.}public void onConnectionFailed(Device device, int error) {	// check failure reason with ERROR_ constants defined in Device.java}public void onConnectionClosed(Device device) {	// either the device was closed using Device.closeConenction(),	// the Bluetooth link was lost, or the device was unpaired.}public void onDevicePaired(Device device) {	if (_device == null) {		tryConnect();	}}public void onDeviceUnpaired(Device device) {	// if the unpaired device had an open connection, onConnectionClosed()	// will be called for all previously added ConnectionListeners}```

Note that, due to Android limitations, it’s not currently possible to determine if a device returned by a call to *Device.getPairedDevices()* has an active Bluetooth link to the host Android device or not. That is to say that, while *Device.getPairedDevices()* may return instances of *Device* for paired devices, any of the Devices returned may be powered off or out of Bluetooth range. For this reason, it’s not uncommon for a call to  *Device.openConnection()* to result in the callback *onConnectionFailed()*with error *ERROR_CONNECTION_TIMEOUT*. If this happens, verify that the Concept 2 is powered on and within range of the host Android device.
###	Querying servicesIndividual service queries can be performed using the *Device.queryUpdate()* method combination with the *SnapshotListener* interface:

```public void queryUpdate {	_device.queryUpdate(this, Device.SERVICE_WEARING_STATE);}public void onSnapshotReceived:(Snapshot snapshot) {	Log.i(TAG, "onSnapshotReceived(): " + snapshot);}
```
###	Subscribing to servicesObserver can use *Device.subscribe()* to register to receive new service data as soon as it is available. The *minPeriod* parameter is used to specify the minumim time period in milliseconds that must pass before new updates as delivered, thus throttling the data rate. A minPeriod of 0 delivers new data as fast as possible.

```Public void subscribe() {	_device.subscribe(this, Device.SERVICE_ORIENTATION, 0);}public void onSnapshotReceived:(Snapshot snapshot) {	if (snapshot.getClass() == OrientationSnapshot.class) {		OrientationSnapshot snap = (OrientationSnapshot)snapshot;		EulerAngles eulerAngles = snap.getEulerAngles();		int heading = (int)Math.round(eulerAngles.getX());		int pitch = (int)Math.round(eulerAngles.getY());		int roll = (int)Math.round(eulerAngles.getZ());		Log.i(TAG, "Orientation: {" + heading,							+ ", " + pitch,							+ ", " + roll + "}");	}}```###	Zeroing servicesThe *Orientation* and *Step Count* services may be configured for the purpose of "zeroing" the data. The process consists of creating a *ServiceConfiguration* for the appropriate class (e.g. *OrientationConfiguration* or *StepCountConfigurtion*), setting a reference orientation/step count, and then applying it using *Device.configure()* method.####	Orientation"Zeroing" orientation allows sets a reference orientation at from which other orientations are based. For example, the device could be zeroed so that the service reports “dead-center” (Euler angles 0,0,0) when the is actually pointing straight up. There are two ways to perform an orientation zero. The first is to call *Device.configure()* supplying *WC_QUATERNION_ZERO* as the reference. This will zero orientation to the current orientation.```OrientationConfiguration config = new OrientationConfiguration(Quaternion.ZeroQuaternion(), OrientationConfiguration.ORIENTATION_REFERENCE_TYPE_BODY);
_device.setConfiguration(config, Device.SERVICE_ORIENTATION);
```The second method is to supply *Device.configure()* with a configuration object containing a specific orientation to zero to.```StepCountConfiguration config = new StepCountConfiguration(0);
_device.setConfiguration(config, Device.SERVICE_STEP_COUNT);
```####	Step CountStep Count configuration is done in a similar manner to orientation, but an offset step count is used instead of reference orientation. Supplying an offset of 0 will use the current step count, thus "zeroing" the service.```OrientationConfiguration config = new OrientationConfiguration(somePreviousSnapshot, OrientationConfiguration.ORIENTATION_REFERENCE_TYPE_BODY);
_device.setConfiguration(config, Device.SERVICE_ORIENTATION);
```

Calling *Device.configure()* with a NULL configuration clears any existing configuration.##		Known Issues
###	Unsubscribing from services before closing connectionThe SDK will not automatically unsubscribe from services when closing a connection. If your app explicitly closes a device connection or otherwise no longer needs service data, it should unsubscribe from the service using *Device*'s *unsubscribe()* method. This will help save power on the device.  